import pathlib
import shutil
from enum import Enum
from typing import List, Optional, Tuple

import argunparse
from pydantic.dataclasses import dataclass
from pydantic import Field

# core holds all the standard class definitions, helper functions and variables we need
# to run a job.

# StirlingClass is the base class for all Stirling objects. This class adds helper functions that all Stirling objects will use.
@dataclass
class StirlingClass:
    pass


# StirlingPluginAssets assets generated by a plugin. This is not
# the same as the commands expected output. Assets are files specifically
# declared for use outside of the plugin; the expected outputs are for the
# command runner to verify that the plugin ran successfully.
@dataclass
class StirlingPluginAssets(StirlingClass):
    """The assets output from a plugin that can be used by other plugins."""

    name: str
    path: pathlib.Path | None


# StirlingPlugin is the base class for all plugins. Any plugin class definition should use this as its parent class.
@dataclass(kw_only=True)
class StirlingPlugin(StirlingClass):
    """StirlingPlugin is the base class for all plugins."""

    name: str
    priority: int
    depends_on: Optional[List[str]] = None
    assets: Optional[List[StirlingPluginAssets]] = None


# StirlingCmdStatus is the status of a current command.
class StirlingCmdStatus(str, Enum):
    QUEUED = "QUEUED"
    RUNNING = "RUNNING"
    CANCELLED = "CANCELLED"
    FAILED = "FAILED"
    SUCCESS = "SUCCESS"


# StirlingCmd objects are structures that hold the final command to run for
# a specific step in a job. A StirlingCmd must include the command to run
# in cli style, and the raw output from the command.
@dataclass(kw_only=True)
class StirlingCmd(StirlingClass):
    """StirlingCmd is the base class for command objects. These command
    objects will be converted into specific commands to run.

    Attributes:
        name (str): The name of plugin that created the command.
        command (str): The string of the command to run.
        priority (int): The priority of the command, this is optional.
            After commands are sorted based on their dependencies, they will
            be sorted by priority. The default is 0, which is the highest
            priority.
        expected_output (str): The output (filename, directory or glob pattern) that we expect to
            be created when this command is run. This is optional.
        depends_on (list): A list of plugins that this plugin depends on before
            it can run. This is optional, and the default is an empty list.
        status (StirlingCmdStatus): The status of the command. The default
            is QUEUED
        log (str): The log output from the command.
    """

    name: str
    command: str | None
    priority: int | None
    expected_output: str | None
    depends_on: List[str] | None
    log: str | None
    status: StirlingCmdStatus = StirlingCmdStatus.QUEUED


@dataclass(kw_only=True)
class StirlingStream(StirlingClass):
    """A stream containing encoded information in a container.

    Attributes:
        stream (int): content_type (str): The type of content in the steam. This
            could be audio, video, subtitle, or the name of a custom type.
        content_type (str): The type of content in the steam. This must match
            a defined StirlingStreamType. Provided types are video, audio or
            subtitle. Custom types can be defined by plugins.
        duration (float): The duration, in seconds, of the stream.
        codec (list(str, str)): A tuple containing the codec's name, or short
            identifier, and the long, or friendly name, of the codec used to
            encode the stream.
    """

    stream: int
    duration: float
    codec: List  # codec_short_name
    content_type: str

@dataclass(kw_only=True)
class StirlingStreamVideo(StirlingStream):
    """The video stream class."""

    width: int
    height: int
    frame_rate: float  # avg_frame_rate
    aspect: Tuple

    bitrate: int
    profile: str
    version: str
    color_model: str
    scan_type: str

    content_type: str = "video"


@dataclass(kw_only=True)
class StirlingStreamAudio(StirlingStream):
    """The audio stream class."""

    name: str
    channels: int
    channel_layout: str

    profile: str
    sample_rate: int
    bit_depth: int

    bitrate: str

    language: str = "und"  # undetermined
    content_type: str = "audio"

    def __post_init__(self):
        self.bitrate = self.bit_depth * self.sample_rate * self.channels


@dataclass(kw_only=True)
class StirlingStreamText(StirlingStream):
    """The text stream class."""

    start_time: float

    dispositions: list
    language: str = "und"  # undetermined

    content_type: str = "subtitle"


@dataclass
class StirlingMediaInfo(StirlingClass):
    """StirlingMediaInfo is the base class for all media information."""

    # TODO: Rewrite this to use one array for all streams instead of separate
    # arrays for each type of stream. This will make it easier to add new
    # stream types in the future.

    source: str
    video_streams: List[StirlingStreamVideo]
    audio_streams: List[StirlingStreamAudio]
    text_streams: List[StirlingStreamText]
    preferred: dict


# VideoEncoderRenditions is a a dict that holds the Video Renditions we support.
# A rendition is a version of the video file that will be transcoded,
# based on the resolution and bitrate settings. The order of these renditions
# is important; the highest-quality rendition should be at the top, followed
# in descending order the remaining lesser-resolution renditions. This is
# because HLS streaming will select the first index.
# These standard profiles should work with any video/audio encoder.
# Quality	    Resolution	bitrate - low	bitrate - high	audio bitrate
# 120p          160x120     96k             128k            32k
# 240p	        426x240	    400k	        600k	        64k
# 360p	        640x360	    700k	        900k	        96k
# 480p	        854x480	    1250k	        1600k	        96k
# 720p	        1280x720	2500k	        3200k	        128k
# 1080p         1920x1080	4500k	        5300k	        128k
# 1080p High  	1920x1080	5800k	        7400k	        192k
# 4k    	    3840x2160	14000k	        18200	        192k
# 4k High   	3840x2160	23000k	        29500k	        192k
# TODO: Finish adding profiles here
VideoEncoderRenditions: dict = {
    "4k-high": {
        "width": "3840",
        "height": "2160",
        "bitrate": "29500",  # KBps
        "audio-bitrate": "192",  # KBps
        "ratio": "16:9",
    },
    "4k": {
        "width": "3840",
        "height": "2160",
        "bitrate": "14000",  # KBps
        "audio-bitrate": "192",  # KBps
        "ratio": "16:9",
    },
    "1080p-high": {
        "name": "1080p-high",
        "width": "1920",
        "height": "1080",
        "bitrate": "7400",  # KBps
        "audio-bitrate": "192",  # KBps
        "ratio": "16:9",
    },
    "1080p": {
        "name": "1080p",
        "width": "1920",
        "height": "1080",
        "bitrate": "7400",  # KBps
        "audio-bitrate": "128",  # KBps
        "ratio": "16:9",
    },
    "720p": {
        "name": "720p",
        "width": "1280",
        "height": "720",
        "bitrate": "7400",  # KBps
        "audio-bitrate": "128",  # KBps
        "ratio": "16:9",
    },
    "480sd": {
        "name": "480p",
        "width": "640",
        "height": "480",
        "bitrate": "800",  # KBps
        "audio-bitrate": "96",  # KBps
        "ratio": "4:3",
    },
    "360sd": {
        "name": "360p",
        "width": "480",
        "height": "360",
        "bitrate": "700",  # KBps
        "audio-bitrate": "96",  # KBps
        "ratio": "4:3",
    },
    "240sd": {
        "name": "240p",
        "width": "320",
        "height": "240",
        "bitrate": "300",  # KBps
        "audio-bitrate": "64",  # KBps
        "ratio": "4:3",
    },
    "120sd": {
        "name": "120p",
        "width": "160",
        "height": "120",
        "bitrate": "128",  # KBps
        "audio-bitrate": "32",  # KBps
        "ratio": "4:3",
    },
}

# VideoEncoderProfiles is a dict that holds the encoder profiles that we support. An
# encoder profile is a collection of renditions for a particular job. When
# creating streaming packages, it's necessary to create multiple renditions of
# an input video. This allows multiple devices, each operating at different
# resolutions and under different network conditions, to choose the video file
# that fits them appropriately. For example, one users might want to access a
# video on be played on a small cell phone in an area with spotty reception,
# while another user may want to play the video on their 4K television with a
# very strong wired internet connection. We call each of these users a "target."
# If we created a single output video, we could create a video that targets one
# or the other, but not both. This would create either an undesirable quality on
# our 4K television or a frustrating loading and buffering experience for our
# cell phone user. By using encoder profiles and modern video streaming encoding
# and formats, we can create a video package that contains a version of the
# video, encoded for multiple targets. Using this, the video player can make its
# own determinations about network availability and quality tradeoffs. This is
# also helpful for our 4K TV target, as no network connection is ever stable. In
# the event of a network slowdown, the 4K TV's video player can decide to revert
# to a lower quality with a smaller bitrate, therefore keeping the video playing
# and limiting buffering and pausing. In each of our VideoEncoderProfiles, we specify
# a list of targets that we want to encode. The Stirling Engine, when encoding a
# streaming video package (such as HLS or DASH), it will create a separate video
# encoding job for each rendition. When each rendition is done, they will be
# merged into one package. The video player only needs the url to our finished
# package, and it will decide which video stream to use.
VideoEncoderProfiles: dict = {
    "sd": [
        VideoEncoderRenditions["120sd"],
        VideoEncoderRenditions["240sd"],
        VideoEncoderRenditions["480sd"],
    ],
    "hd": [
        VideoEncoderRenditions["720p"],
        VideoEncoderRenditions["1080p"],
        VideoEncoderRenditions["1080p-high"],
    ],
}


def check_dependencies_binaries(required_binaries: list) -> bool:
    required_binaries_missing = []
    for program in required_binaries:
        if shutil.which(program) is None:
            required_binaries_missing.append(program)
    if not len(required_binaries_missing) == 0:
        return "missing binary dependencies: {}".format(
            " ".join(required_binaries_missing)
        )
    return True


default_unparser = argunparse.ArgumentUnparser(long_opt="--", opt_value=" ")
autosub_unparser = argunparse.ArgumentUnparser(long_opt="--", opt_value="=")
ffmpeg_unparser = argunparse.ArgumentUnparser(
    long_opt="-", opt_value=" ", begin_delim="", end_delim=""
)
